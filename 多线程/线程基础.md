1、线程属于”一次性”用品，不能通过重新调用已结束的线程的start方法来使其重新运行。多次调用同一个线程的start方法会导致抛出IllegalThreadStateExcetpion 

2、线程就是一个对象，创建线程和创建其他java对象不同的是，jvm会为每个线程分配调用栈（Call stack）所需的内存 

3、创建线程的2种方式： 

1. 基于继承的技术，创建Thread的子类 
2. 基于组合的技术，向Thread传入实现了Runnable接口的实例 

组合相对于继承来说，类和类之间的耦合性更低，优先使用 

4、线程属性 

| 属性                | 属性类型&用途                    | 是否只读 | 注意事项                                                     |
| ------------------- | -------------------------------- | -------- | ------------------------------------------------------------ |
| 编号 （ID）         | 类型：long 用于标识线程          | 是       | 某个线程结束后，该编号可能被后续的线程使用                   |
| 名称（Name）        | 类型：String                     | 否       | 该属性必须在线程启动前设置 关键任务处理线程不要设置成守护线程 |
| 守护线程（Daemon）  | 类型：boolean                    | 否       | 守护线程不会影响jvm正常停止 而只有在用户线程都结束，jvm才会正常停止 |
| 优先级 （Priority） | 类型：int 默认为5 取值范围[1,10] | 否       | 一般默认优先级即可，不当设置可能会导致某些线程永远无法运行（线程饥饿） |

5、Thread类的常用方法 

| 方法                           | 功能                                                       | 备注                                                         |
| ------------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| static Thread currentThread()  | 返回当前线程                                               |                                                              |
| void run()                     | 处理逻辑                                                   |                                                              |
| void start()                   | 启动线程                                                   | 只能调用一次                                                 |
| void join()                    | 等待相应线程运行结束                                       | 若线程A调用线程B的join方法，那么线程A的运行被暂停，直到线程B运行结束 |
| static void yield()            | 使当前线程主动放弃其对处理器的占用，可能导致当前线程被暂停 | 该方法被调用时当前线程可能仍然继续运行                       |
| static void sleep(long millis) | 使当前线程休眠                                             |                                                              |

6、一个线程是否是一个守护线程默认取决于其父线程：默认情况下父线程是守护线程，则子线程也是守护线程。父线程在创建子线程之前可以调用setDaemon设置成守护线程 

7、线程状态图 

8、线程转储方法： 

1. 执行jstack -l PID 
2. 单击图形化工具jvissualvm 
3. 使用Java Mission Control(JMC) 