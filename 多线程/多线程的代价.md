多线程也会带来一些缺点，例如会产生上下文切换，资源的争用，使用不当还会产生线程的活性故障

# 1. 上下文切换

线程在获得时间片进行切入和时间片用完进行切出的时候操作系统需要保存和恢复相应线程的进度信息，这个进度信息被称为**上下文**。一般包括**通用寄存器**和**程序计数器**的内容。

一个线程在RUNNABLE状态和非RUNNABLE状态切换的过程就是上下文切换的过程。

## 1.1 上下文切换的分类

### 1.11 自发性上下文切换

+ Thread.sleep(long minllis)
+ Object.wait()
+ Thread.yield();
+ Thread.join();
+ LockSupport.park()
+ 阻塞式I/O

### 1.12 非自发性上下文切换

+ 时间片用完
+ 垃圾回收导致的stop-the-word

## 1.2 上下文切换的开销

直接开销:

+ 操作系统保存和恢复上下文所需的开销，处理器时间的开销
+ 线程调度器进行线程调度的开销

间接开销：

+ 处理器高速缓存重新加载的开销，切入进来的线程可能和之前切出的线程运行在2个处理器上，就需要缓存同步
+ 可能导致整个一级高速缓存中的内容被冲刷（FLush），即一级高速缓存中的内容被写入下一级高速缓存或主内存。

**一次上下文切换的时间消耗是*微秒（us）*级的**

查看java程序上下文次数和频率的命令：

```shell
perf stat -e cpu-clock,task-clock,cs,cache-refernces,cache-misses java ...
```

# 2.资源争用与调度

**公平调度策略**：资源的任何一个先申请者总是比任何一个后申请者先获得资源，即不允许插队现象的出现。只有在资源未被任何线程占用，并且等待队列为空，才允许线程抢占资源

|      策略      |                      优点                       |                       缺点                       |
| :------------: | :---------------------------------------------: | :----------------------------------------------: |
|  公平调度策略  | 不会导致饥饿现象<br/>申请资源所需的时间偏差较小 |                     吞吐量小                     |
| 非公平调度策略 |                    吞吐量大                     | 可能会导致饥饿现象<br />申请资源所需时间偏差较大 |

**策略的选择**：

资源的持有线程释放资源的时候，等待队列中一个线程会被唤醒，而该线程到继续运行可能需要一段时间，如果新来的线程占用资源的时间不长，那么完全有可能在被唤醒线程继续其运行前释放相应的资源，从而不影响被唤醒线程申请资源，从而不影响被唤醒的线程申请资源，非公平调度策略就会减少上下文切换的次数。但是如果多数线程占用资源时间很长，那么允许新来的线程抢占资源就不会有任何好处，反而会导致被唤醒的线程需要再次经历暂停和唤醒，增加了上下文切换的次数。

因此**多数情况首选非公平的调度策略**，以下场景适合用公平策略：

+ 多数线程占用资源时间比较长的场景
+ 资源的平均申请时间间隔相对长的情况
+ 对资源申请的时间偏差有所要求的场景