## 1 volatile关键字的作用

**volatile变量不会被编译器分配到寄存器进行存储，对volatile变量的读写都是内存访问（访问高速缓存相当于主内存）操作**。

+ 保证可见性。
+ 保证有序性。
+ 保证volatile变量写操作的原子性

对于volatile变量的写操作，java虚拟机会在该操作**之前**插入一个**释放屏障**，并在该操作**之后**插入一个**存储屏障**。

对于volatile变量的读操作，java虚拟机会在该操作**之前**插入一个**加载屏障**，并在该操作**之后**插入一个**获取屏障**。

### 保证可见性的方式：

加载屏障通过冲刷处理器缓存，使得读线程所在的处理器将其他处理器对共享变量所做的更新同步到该处理器的高速缓存中。读线程执行的加载屏障和写线程执行的存储屏障配合一起使得写线程对volatile变量的写操作以及在此之前所执行的其他内存操作对读线程可见。

volatile关键词会被JIT编译器看作一个提示，从而使JIT编译器不会对相应代码做出一些优化。（例如循环提升）

volatile不具备排他性，因此它**不能保证**读线程读取到的共享变量的值是**最新的**，即读线程读取到这些共享变量的那一刻可能已经有其他线程更新了这些共享变量的值。

### 保证有序性的方式：

释放屏障禁止了volatile写操作与该操作之前的任何读、写操作进行重排序，从而保证了volatile写操作之前的任何读、写操作会先于volatile写操作被提交。即其他线程看到写线程对volatile变量的更新时，写线程在volatile变量之前的执行结果对读线程是可见的。

获取屏障禁止了volatile读操作之后的任何读、写操作与volatile读操作进行重排序。因此它保障了写线程对volatile修饰的共享变量的更新，对volatile读操作之后的任何操作可见。

![volatile与内存屏障](/Users/xuebo/Documents/note/多线程/volatile与内存屏障.jpg)

对于引用型volatile变量，volatile关键字只是保证线程能够读取到一个指向对象的相对新的地址（引用），而这个内存地址指向的对象的实例/静态变量是否是相对新的则没有保障

##2 volatile变量的开销

**volatile变量的读、写操作都不会导致上下文切换**，因此volatile的开销比锁小。介于普通变量和临界区内的读写之间。

volatile变量每次都需要从高速缓存或者主内存中读取，而无法被暂存在寄存器中。



