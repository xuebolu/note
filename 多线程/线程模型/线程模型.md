## 1. 进程、线程、纤程

+ 进程：资源分配的最小单元
+ 线程：程序执行的最小单元
+ 纤程（协程）：轻量级线程

在早期的linux系统里，是没有线程支持的，操作系统分配资源的单位是进程，然后执行单元也是进程。说详细点就是，每个进程有自己的内存，文件描述符，IO端口等，你不能随便访问其他进程的资源，分配给你，就是你的了，别人看不到。而那时候的进程都是单线程的，所有的进程在同一个CPU上分时执行。

后来，使用并发程序提高程序的速度以后（还有安全的考虑），一个进程做为一个执行单元就有些重了。这时就引入了线程的实现。线程有自己的独立的栈，调度也依赖操作系统，但是大家还是不满意，觉得线程消耗资源太大了，例如在linux上，一个线程默认的栈大小是1M，创建几万个线程就压力山大。所以，后来在编程语言的层面上，就有了协程这个东西

## 2.系统调用

假设没有这种内核态和用户态之分，程序随随便便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。

系统调用的过程会发生 CPU 上下文的切换，CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

## 3. 用户态和内核态

不同CPU都有不同的运行级别，x86的CPU的运行级别分别为

+ ring0
+ ring1
+ ring2
+ ring3

其中linux只用到了ring0和ring3,分别对应的是内核态和用户态

0x80

#### 什么情况下会发生从用户态向内核态切换？

+ 系统调用
+ 异常：比如缺页异常
+ 外围设备中断

##4. 线程模型

### 4.1 1:1模型（内核线程模型）

**优点：**

- 实现简单

**缺点：**

- 对用户线程的大部分操作都会映射到内核线程上，引起用户态和内核态的频繁切换；
- 内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响；

### 4.2 n:1模型（用户线程模型）

**优点：**

- 用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换，使线程的创建、调度、同步等非常快；

**缺点：**

- 由于多个用户线程对应到同一个内核线程，如果其中一个用户线程阻塞，那么该其他用户线程也无法执行；
- 内核并不知道用户态有哪些线程，无法像内核线程一样实现较完整的调度、优先级等；

### 4.3 m:n模型

多对多模型，又叫作两级线程模型，它是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。

在此模型下，用户线程与内核线程是多对多（m : n，通常m>=n）的映射模型。

首先，区别于多对一模型，多对多模型中的一个进程可以与多个内核线程关联，于是进程内的多个用户线程可以绑定不同的内核线程，这点和一对一模型相似；

其次，又区别于一对一模型，它的进程里的所有用户线程并不与内核线程一一绑定，而是可以动态绑定内核线程， 当某个内核线程因为其绑定的用户线程的阻塞操作被内核调度让出CPU时，其关联的进程中其余用户线程可以重新与其他内核线程绑定运行。

所以，多对多模型既不是多对一模型那种完全靠自己调度的也不是一对一模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现。

**优点：**

- 兼具多对一模型的轻量；
- 由于对应了多个内核线程，则一个用户线程阻塞时，其他用户线程仍然可以执行；
- 由于对应了多个内核线程，则可以实现较完整的调度、优先级等；

**缺点：**

- 实现复杂

Go语言使用的是多对多线程模型，这也是其高并发的原因，它的线程模型与Java中的ForkJoinPool非常类似；

## 5. Hotspot创建线程

