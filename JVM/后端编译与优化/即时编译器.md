当虚拟机发现某个

### 为何HotSpot要实现两个（或三个）不同的即时编译器？

+ 客户端编译器（Client Compiler）：即C1编译器
+ 服务端编译器（Server Compiler）：即C2编译器
+ Graal编译器：JDK 10才出现。长期目标是替代C2编译器

在分层编译（Tiered Compilation）的工作模式出现以前，HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，使用哪个编译器，只取决于虚拟机的运行模式。使用-client或-server参数去指定使用客户端模式还是服务端模式。

由于即时编译器编译本地代码需要占用程序运行时间，通常编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息。这对解释执行阶段的速度也有影响，为了程序启动速度与运行速度达到最佳平衡，引入了**分层编译**的功能
JDK7作为默认编译策略开启

### 分层编译

+ 第0层。程序纯解释执行，解释器不开启性能监控功能
+ 第1层。使用客户端编译器将字节码编译为本地代码运行，不开启性能监控功能
+ 第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等性能监控功能
+ 第3层。仍然使用客户端编译器执行。开启全部性能监控，分支跳转，虚方法调用版本等
+ 第4层。使用服务端编译器将字节码编译为本地代码

###哪些程序代码会被编译为本地代码？如何编译本地代码？

	+ 被多次调用的方法
	+ 被多次执行的循环体

### 热点探测方式

+ 基于采样的热点探测
+ 基于计数器的热点探测