##1.分代假说

+ 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的
+ 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡

这两个分代假说奠定了一致性的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域存储

一般把Java堆分为新生代和老年代两个区域。

##2.跨代引用假说

**对象不是孤立的，对象之间会存在跨代引用**

假如现在进行一次新生代的垃圾收集（Minor GC）,但新生代完全有可能被老年代引用，为了找出该区域中存活的对象，不得不在固定的GC Root之外，再额外遍历整个老年代中所有对象来确保可达性分析的正确性。反过来也一样，为解决这个问题，需要对分代收集理论新增一条法则

**跨代引用假说：跨代引用相对于同代引用来说仅占极少数**

依据这条假说，我们就不应在为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每个对象是否存在及存在哪些跨代引用。

只需在新生代建立一个全局的数据结构Remembered Set，只有包含了跨代引用的小块内存里的对象才会被加入到GC Root 进行扫描。

虽然这种方式需要在对象改变引用关系时维护记录数据的正确性，但比起扫描整个老年代来说仍然是划算的

##3.标记-清除算法 

+ 优点
  + 不需要对象移动
+ 缺点
  + 内存碎片
  + 执行效率随着对象数量增长而降低，如果有大量需要被回收的，必须进行大量标记和清除的动作

## 4.停止-复制算法

+ 优点
  + 没有内存碎片
  + 运行高效
+ 缺点
  + 对象移动，适合存活对象较少的场景
  + 空间浪费
  + 需要分配担保，否则可能oom

### 分配担保

Survivor空间不足，需要老年代进行担保，分配担保会引发**promotion failed(晋升失败)和Concurrent Mode Failure(并发模式失败)的问题**

## 5.标记-整理算法

+ 优点
  + 没有内存碎片
  + 不需要对象移动
+ 缺点
  + 需要对象移动
  + 性能差

**一般吞吐量优先的垃圾收集器更多使用标记整理算法，低停顿时间的垃圾收集器更多使用标记清除算法**

